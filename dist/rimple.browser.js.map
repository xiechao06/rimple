{"version":3,"file":"rimple.browser.js","sources":["op/boolean.js","op/object.js","op/number.js","op/list.js","index.js"],"sourcesContent":["/**\n * these are a group of operations to mutate a slot with value type of boolean\n *\n * @lends Slot.prototype\n *\n * */\nexport default {\n  /**\n   * toggle the Slot's value\n   * @return {Slot} this\n   * */\n  toggle() {\n    return this.val(!this.val());\n  },\n  /**\n   * make the Slot's value to be true\n   * @return {Slot} this\n   * */\n  on() {\n    return this.val(true);\n  },\n  /**\n   * make the Slot's value to be false\n   * @return {Slot} this\n   * */\n  off() {\n    return this.val(false);\n  }\n};\n\n","/**\n * these are a group of operations to mutate a slot with value type of Object\n *\n * @lends Slot.prototype\n *\n * */\nconst patch = {\n  /**\n   * patch the object value\n   * @example\n   * const $$s = $$({ name: 'Tom', color: 'Blue' });\n   * $$s.patch({ name: 'Jerry', species: 'Mouse' });\n   * console.log($$s.val()); // { name: 'Jerry', species: 'Mouse', colur: 'Blue' }\n   *\n   * @param {object} obj - object used to patch me\n   * @return {Slot} this\n   *\n   * */\n  patch(obj) {\n    this.debug && console.info(\n      `slot: slot ${this.tag()} is about to be patched`, obj\n    );\n    return this.val(Object.assign({}, this.val(), obj));\n  },\n  /**\n   * omit the keys\n   * @example\n   * const $$s = $$({ name: 'Tom', color: 'Blue' });\n   * $$s.omit(['color']);\n   * console.log($$s.val(); // { name: 'Tom' }\n   *\n   * @return {Slot} this\n   * */\n  omit(keys) {\n    for (let field of keys) {\n      delete this._value[field];\n    }\n    return this.val(Object.assign({}, this._value));\n  },\n  /**\n   * set the property of Slot's value\n   * @example\n   * const $$s = $$({ name: 'Tom', color: 'Red' });\n   * $$s.set('color', 'Blue');\n   * console.log($$s.val(); // { name: 'Tom', color: 'Red' }\n   *\n   * @return {Slot} this\n   * */\n  set(prop, value) {\n    if (typeof value == 'function') {\n      value = value.apply(this, [this._value[prop]]);\n    }\n    this._value[prop] = value;\n    this.val(\n      Array.isArray(this._value)?\n        [].concat(this._value):\n        Object.assign({}, this._value)\n    );\n    return this;\n  },\n  /**\n   * set the deep property of Slot's value\n   * @example\n   * const $$s = $$({ name: 'Tom' });\n   * $$s.setIn(['friend', 'name'], 'Jerry');\n   * console.log($$s.val(); // { name: 'Tom', frien: { 'name': 'Red'} }\n   *\n   * @example\n   * const s = slot({});\n   * s.setIn(['a', 1], 'abc'); // { a: [, 'abc'] }\n   *\n   * @return {Slot} this\n   * */\n  setIn(path, value) {\n    let o = this._value;\n    for (let i = 0; i < path.length - 1; ++i) {\n      let seg = path[i];\n      let nextSeg = path[i + 1];\n      o[seg] = o[seg] || (Number.isInteger(nextSeg)? []: {});\n      o = o[seg];\n    }\n    let lastSeg = path[path.length - 1];\n    if (typeof value == 'function') {\n      value = value.apply(this, [o[lastSeg]]);\n    }\n    o[lastSeg] = value;\n    this.val(Object.assign({}, this._value));\n    return this;\n  }\n};\n\npatch.assoc = patch.set;\npatch.assocIn = patch.setIn;\n\nexport default patch;\n","/**\n * these are a group of operations to mutate a slot with value type of number\n *\n * @lends Slot.prototype\n *\n * */\nconst numberOps = {\n\n  /**\n   * increment the slot's value, the slot's value should be of type number\n   *\n   * @param {number} cnt - the value to be added, default is 1\n   * @return {Slot} this\n   * */\n  inc(cnt=1) {\n    return this.val(this.val() + cnt);\n  },\n\n  /**\n   * decrement the slot's value, the slot's value should be of type number\n   *\n   * @param {number} cnt - the value to be deremented, default is 1\n   * @return {Slot} this\n   * */\n  dec(cnt=1) {\n    return this.val(this.val() - cnt);\n  },\n\n  /**\n   * get remainder the slot's value, the slot's value should be of type number\n   *\n   * @example\n   * const $$s = $$(17).mod(7);\n   * console.log($$s.val());  // output 3\n   *\n   * @param {number} n - the divisor\n   * @return {Slot} this\n   * */\n  mod(n) {\n    return this.val(this.val() % n);\n  },\n  /**\n   * multiply the slot's value by n, the slot's value should be of type number\n   *\n   * @param {number} n - the multiplier\n   * @return {Slot} this\n   * */\n  multiply(n) {\n    return this.val(this.val() * n);\n  },\n\n  /**\n   * divides the slot's value by n, the slot's value should be of type number\n   *\n   * @param {number} n - the divisor\n   * @return {Slot} this\n   * */\n  divide(n) {\n    return this.val(this.val() / n);\n  }\n};\n\nexport default numberOps;\n","/**\n * these are a group of operations to mutate a slot with value type of array\n *\n * @lends Slot.prototype\n *\n * */\nexport default {\n  /**\n   * concat the Slot's value with an array\n   *\n   * @param {array} arr\n   * @return {Slot} this\n   * */\n  concat(arr) {\n    return this.val([].concat(this.val()).concat(arr));\n  },\n  /**\n   * map the Slot's value with a function\n   *\n   * @example\n   * const $$s = $$([1, 2, 3]);\n   * console.log($$s.map(it => it * 2).val()); // 2, 4, 6\n   *\n   * @param {function} fn\n   * @return {Slot} this\n   * */\n  map(fn) {\n    return this.val(this.val().map(fn));\n  },\n  /**\n   * filter the Slot's value with a function\n   *\n   * @example\n   * const $$s = $$([1, 2, 3, 4]);\n   * console.log($$s.filter(it => it % 2 == 0).val()); // 2, 4\n   *\n   * @param {function} fn\n   * @return {Slot} this\n   * */\n  filter(fn) {\n    let val = this.val();\n    return this.val(val.filter(fn));\n  },\n  /**\n   * slice the Slot's value\n   *\n   * @example\n   * const $$s = $$([1, 2, 3, 4]);\n   * console.log($$s.slice(1, 2).val()); // [2]\n   *\n   * @return {Slot} this\n   * */\n  slice() {\n    let val = this.val();\n    return this.val(val.slice.apply(val, Array.from(arguments)));\n  },\n  /**\n   * shift the Slot's value\n   *\n   * @example\n   * const $$s = $$([1, 2, 3, 4]);\n   * console.log($$s.shift().val()); // 2, 3, 4\n   *\n   * @return {Slot} this\n   * */\n  shift() {\n    this.val().shift();\n    this.val([].concat(this.val()));\n    return this;\n  },\n  /**\n   * shift the Slot's value\n   *\n   * @example\n   * const $$s = $$([2, 3, 4]);\n   * console.log($$s.unshift(1).val()); // 1, 2, 3, 4\n   *\n   * @return {Slot} this\n   * */\n  unshift(o) {\n    this.val().unshift(o);\n    this.val([].concat(this.val()));\n    return this;\n  },\n  /**\n   * push the Slot's value\n   *\n   * @example\n   * const $$s = $$([1, 2, 3]);\n   * console.log($$s.push(4).val()); // 1, 2, 3, 4\n   *\n   * @return {Slot} this\n   * */\n  push(o) {\n    this.val().push(o);\n    this.val([].concat(this.val()));\n    return this;\n\n  },\n  /**\n   * push the Slot's value\n   *\n   * @example\n   * const $$s = $$([1, 2, 3]);\n   * console.log($$s.pop().val()); // 1, 2\n   *\n   * @return {Slot} this\n   * */\n  pop() {\n    this.val().pop();\n    this.val([].concat(this.val()));\n    return this;\n  },\n  /**\n   * reverse the Slot's value\n   *\n   * @example\n   * const $$s = $$([1, 2, 3]);\n   * console.log($$s.pop().val()); // [3, 2, 1]\n   *\n   * @return {Slot} this\n   * */\n  reverse() {\n    this.val([].concat(this.val().reverse()));\n    return this;\n  }\n};\n","import booleanOps from './op/boolean';\nimport objectOps from './op/object';\nimport numberOps from './op/number';\nimport listOps from './op/list';\n\nconst _uniqueId = function _uniqueId() {\n  let i = 1;\n  return function (prefix='') {\n    return prefix + i++;\n  };\n}();\n\nconst _isEmptyObj = function _isEmptyObj(obj) {\n  for(const key in obj) {\n    if(obj.hasOwnProperty(key))\n      return false;\n  }\n  return true;\n};\n\nconst _objectValues = function _objectValues(obj) {\n  if (Object.values) {\n    return Object.values(obj);\n  }\n  const values = [];\n  for (let key in obj){\n    if (obj.hasOwnProperty(key)) {\n      values.push(obj[key]);\n    }\n  }\n  return values;\n};\n\n/**\n * @constructor\n *\n * @desc A Slot could be created in 2 methods:\n *\n *  * new Slot(value)\n *\n *  this will make a data slot\n *\n *  * new Slot(valueFunc, followings)\n *\n *  this will make a follower slot, where followings is an Array.\n *  if the element (say *following*) in observables is a:\n *\n *    * Slot\n *\n *      if *following* changed, *follower* will be re-evaludated by executing *valueFunc*,\n *      following.val() will be used as valueFunc's argument.\n *      its new value is the return value of *valueFunc*, and change will be propogated to\n *      *follower*'s followers.\n *\n *    * not Slot\n *\n *      when *follower* is re-evaluated, following will be used as *valueFunc*'s argument directly.\n *\n *  and valueFunc will accept 2 parameters:\n *\n *    * the current value of observables\n *    * mutation process context, it has two keys:\n *\n *      * roots - the mutation process roots, namely, those changed by clients (api caller)\n *        directly\n *\n *      * involved - the observed involed in this mutation process\n *\n *      the context is very useful if the evaluation function needs to return value\n *      according to which of its followings mutated\n *\n *  let's see two example:\n *\n *  ```javascript\n *\n *  const $$following = Slot(1);\n *  const $$follower = Slot((following, n) => following + n, [$$following, 2]);\n *  console.log($$follower.val()); // output 3, since n is always 2\n *\n *  $$following.inc();\n *  console.log($$follower.val()); // output 4, since n is always 2\n *  ```\n *\n *  ```javascript\n *\n *  const $$a = Slot(1).tag('a');\n *  const $$b = Slot(([a]) => a + 1, [$$a]).tag('b');\n *  const $$c = Slot(2).tag('c');\n *  const $$d = Slot(function ([a, b], {roots, involved}) {\n *    console.log(roots.map(it => it.tag())); // output [a]\n *    console.log(involved.map(it => it.tag())); // output [b]\n *    return a + b;\n *  });\n *\n *  // a is root of mutation proccess, and c is not changed in this mutation proccess\n *  $$a.inc();\n *\n *  ```\n *\n * */\nexport const Slot = function Slot(...args) {\n  if (!(this instanceof Slot)) {\n    return new Slot(...args);\n  }\n  this._id = _uniqueId();\n  this._changeCbs = [];\n  this._followings = [];\n  this._followerMap = {};\n  // offsprings are all direct or indirect followers\n  this._offspringMap = {};\n  this._offspringLevels = [];\n  this._tag = '';\n  Object.defineProperty(this, 'token', {\n    get: function get() {\n      return this._tag + '-' + this._id;\n    }\n  });\n  Object.defineProperty(this, 'followings', {\n    get: function get() {\n      return this._followings;\n    }\n  });\n  Object.defineProperty(this, 'followers', {\n    get: function get() {\n      return _objectValues(this._followerMap);\n    }\n  });\n  if (args.length <= 1) {\n    this._value = args[0];\n  } else {\n    const [valueFunc, followings, eager] = args;\n    this.follow(valueFunc, followings, eager);\n  }\n};\n\n/**\n * test if slot observes others\n * @return {boolean} true if it observes others, else false\n * */\nSlot.prototype.isTopmost = function isTopmost() {\n  return !this._followings.length;\n};\n\n/**\n * Set/get tag of slot, useful when debugging.\n *\n * @example\n * // set tag will return this\n * const $$s = Slot('foo').tag('bar');\n * console.log($$s.tag()); // output bar\n *\n * @param {(string|undefined)} v - if is string, set the tag of slot and return this,\n * else return the tag\n * @return {(string|Slot)}\n * */\nSlot.prototype.tag = function tag(v) {\n  if (v == void 0) {\n    return this._tag;\n  }\n  this._tag = v;\n  return this;\n};\n\n/**\n * set a handler to Slot to test if slot is mutated, here is an example:\n *\n * @example\n * let $$s1 = Slot(true);\n * let $$s2 = Slot(false);\n *\n * let $$s3 = Slot((s1, s2) => s1 && s2, [$$s1, $$s2])\n * .mutationTester((oldV, newV) => oldV != newV);\n *\n * $$s4 = $$s3.makeFollower((s3) => !s3)\n * .change(function () {\n *    console.log('s4 changed!');\n * });\n *\n * // $$s2 will be changed to true, but $$s3 is not changed,\n * // neither $$s4 will be changed\n * $$s2.toggle();\n *\n *\n * @param {function} tester - a handler to test if slot is changed in one mutation\n * process, if a slot finds all its dependents are unmutation, the mutation process\n * stops from it.\n * A propriate tester will improve the performance dramatically sometimes.\n *\n * it access slot as *this* and slot's new value and old value as arguments,\n * and return true if slot is changed in mutation process, else false.\n *\n * */\nSlot.prototype.mutationTester = function mutationTester(tester) {\n  this._mutationTester = tester;\n  return this;\n};\n\n/**\n * add a change handler\n *\n * !!!Warning, this is a very dangerous operation if you modify slots in\n * change handler, consider the following scenario:\n *\n * ```javascript\n *  let $$s1 = Slot(1);\n *  let $$s2 = $$s1.makeFollower(it => it * 2);\n *  let $$s3 = $$s1.makeFollower(it => it * 3);\n *  $$s2.change(function () {\n *    $$s1.val(3); // forever loop\n *  ));\n *\n *  $$s1.val(2);\n * ```\n *\n *\n *  as a thumb of rule, don't set value for followings in change handler\n *\n * @param {function} proc - it will be invoked when slot is mutated in one\n * mutation process the same order as it is added, it accepts the following\n * parameters:\n *\n *   * new value of Slot\n *   * the old value of Slot\n *   * the mutation context\n *\n * for example, you could refresh the UI, when ever the final view changed\n *\n * @return {Slot} this\n *\n * */\nSlot.prototype.change = function (proc) {\n  this._changeCbs.push(proc);\n  return this;\n};\n\n/**\n * remove the change handler\n *\n * @see {@link Slot#change}\n * */\nSlot.prototype.offChange = function (proc) {\n  this._changeCbs = this._changeCbs.filter(cb => cb != proc);\n};\n\nSlot.prototype.clearChangeCbs = function clearChangeCbs() {\n  this._changeCbs = [];\n};\n\n/**\n * detach the target slot from its followings, and let its followers\n * connect me(this), just as if slot has been eliminated after the detachment.\n * this method is very useful if you want to change the dependent graph\n *\n * !!NOTE this method will not re-evaluate the slot and starts the mutation process\n * at once, so remember to call touch at last if you want to start a mutaion process\n *\n * @param {Slot} targetSlot\n * @return {Slot} this\n *\n * */\nSlot.prototype.override = function override(targetSlot) {\n  for (let following of targetSlot._followings) {\n    delete following._followerMap[targetSlot._id];\n  }\n  for (let followerId in targetSlot._followerMap) {\n    let follower = targetSlot._followerMap[followerId];\n    this._followerMap[followerId] = follower;\n    for (let i = 0; i < follower._followings.length; ++i) {\n      if (follower._followings[i]._id == targetSlot._id) {\n        follower._followings[i] = this;\n        break;\n      }\n    }\n  }\n  this._offspringMap = this._offspringLevels = void 0;\n  // make ancestors _offspringMap obsolete, why not just calculate _offspringMap\n  // for each ancestor? since this operation should be as quick as possible\n  // and multiple override/replaceFollowing/connect operations could be batched,\n  // since the calculation of springs of ancestors postponed to the moment\n  // when ancestor is evaluated\n  targetSlot._getAncestors().forEach(function (ancestor) {\n    ancestor._offspringLevels = ancestor._offspringMap = void 0;\n  });\n  return this;\n};\n\n\n/**\n * replaceFollowing, why not just re-follow, since follow is a quite\n * expensive operation, while replaceFollowing only affect the replaced one\n *\n * !!NOTE this method will not re-evaluate the slot and starts the mutation process\n * at once, so remember to call touch at last if you want to start a mutaion process\n *\n * @param idx the index of following\n * @param following a slot or any object, if not provided, the \"idx\"th following will\n * not be followed anymore.\n *\n * @return {Slot} this\n */\nSlot.prototype.replaceFollowing = function replaceFollowing(idx, following) {\n  let args = [idx, 1];\n  if (following != void 0) {\n    args.push(following);\n  }\n  let [replaced] = this.followings.splice.apply(this.followings, args);\n  // replace the same following, just return\n  if (replaced == following) {\n    return this;\n  }\n  if (replaced instanceof Slot) {\n    delete replaced._followerMap[this._id];\n    replaced._offspringLevels = replaced._offspringMap = void 0;\n    replaced._getAncestors().forEach(function (ancestor) {\n      ancestor._offspringLevels = ancestor._offspringMap = void 0;\n    });\n  }\n  if (following instanceof Slot) {\n    following._offspringLevels = following._offspringMap = void 0;\n    // make ancestors _offspringMap obsolete\n    following._getAncestors().forEach(function (ancestor) {\n      ancestor._offspringLevels = ancestor._offspringMap = void 0;\n    });\n  }\n  return this;\n};\n\n/**\n * this is the shortcut of replaceFollowing(idx)\n *\n * !!NOTE this method will not re-evaluate the slot and starts the mutation process\n * at once, so remember to call touch at last if you want to start a mutaion process\n *\n * @param {number} idx - the index of\n * */\nSlot.prototype.removeFollowing = function removeFollowing(idx) {\n  return this.replaceFollowing(idx);\n};\n\n// propogate from me\nSlot.prototype._propogate = function ({ roots }) {\n  // if has only one follower, touch it\n  let followers = _objectValues(this._followerMap);\n  if (followers.length == 0) {\n    return;\n  }\n  if (followers.length == 1) {\n    followers[0].touch(true, { roots, involved: [this] });\n    return;\n  }\n  if (this._offspringLevels === void 0 || this._offspringMap === void 0) {\n    this._setupOffsprings();\n  }\n  let cleanSlots = {};\n  // mutate root is always considered to be dirty,\n  // otherwise it won't propogate\n  let mutateRoot = this;\n  let changeCbArgs = [];\n  for (let level of this._offspringLevels) {\n    for (let follower of level) {\n      let involved = follower._followings.filter(function (following) {\n        return following instanceof Slot &&\n          (following._id === mutateRoot._id ||\n           (mutateRoot._offspringMap[following._id] && !cleanSlots[following._id]));\n      });\n      // clean follower will be untouched\n      let dirty = involved.length > 0;\n      if (!dirty) {\n        cleanSlots[follower._id] = follower;\n        continue;\n      }\n      follower.debug && console.info(`slot: slot ${follower._tag} will be refreshed`);\n      let context = {involved, roots};\n      let oldV = follower._value;\n      // DON'T CALL change callbacks\n      if (follower.touch(false, context, false)) {\n        changeCbArgs.push([follower, oldV, involved]);\n      } else {\n        cleanSlots[follower._id] = follower;\n      }\n    }\n  }\n  // call change callbacks at last\n  changeCbArgs.forEach(function ([slot, oldV, involved]) {\n    for (let cb of slot._changeCbs) {\n      cb.apply(slot, [slot._value, oldV, { involved, roots }]);\n    }\n  });\n};\n\n/**\n * get or set the value, if no argument is given, get the current value of Slot,\n * otherwise, set the value of Slot, *the mutation process* starts, and returns *this*\n *\n * @return {(any|Slot)}\n * */\nSlot.prototype.val = function val(...args) {\n  if (args.length === 0) {\n    if (this._value === void 0 && typeof this._valueFunc === 'function') {\n      this._value = this._valueFunc.apply(\n        this, [\n          this._followings.map(it => it instanceof Slot? it.val(): it),\n          { roots: [ this ] },\n        ]\n      );\n    }\n    return this._value;\n  }\n  return this.setV(args[0]);\n};\n\n/**\n * set the slot's value, and starts a *mutation process*\n *\n * @param {any} newV - the new value of slot,\n * */\nSlot.prototype.setV = function setV(newV) {\n  if (typeof this._mutationTester === 'function' && !this._mutationTester(this._value, newV)) {\n    return this;\n  }\n  this.debug && console.info(\n    `slot: slot ${this._tag} mutated -- `, this._value, '->', newV\n  );\n  let oldV = this._value;\n  this._value = newV;\n  this._propogate({ roots: [this] });\n  for (let cb of this._changeCbs) {\n    cb.apply(this, [this._value, oldV, {\n      roots: [this],\n    }]);\n  }\n  return this;\n};\n\n\nconst _colletFollowers = function _colletFollowers(slots) {\n  let ret = {};\n  for (let o of slots) {\n    for (let k in o._followerMap) {\n      let follower = o._followerMap[k];\n      ret[follower._id] = follower;\n    }\n  }\n  return _objectValues(ret);\n};\n\nSlot.prototype._setupOffsprings = function () {\n  this._offspringMap = {};\n  this._offspringLevels = [];\n  if (_isEmptyObj(this._followerMap)) {\n    return this;\n  }\n  // level by level\n  for (\n    let _offspringMap = _objectValues(this._followerMap), level = 1;\n    _offspringMap.length;\n    _offspringMap = _colletFollowers(_offspringMap), ++level\n  )  {\n    for (let i of _offspringMap) {\n      if (!(i._id in this._offspringMap)) {\n        this._offspringMap[i._id] = {\n          slot: i,\n          level: level\n        };\n      } else {\n        this._offspringMap[i._id].level = Math.max(\n          this._offspringMap[i._id].level, level\n        );\n      }\n    }\n  }\n  let currentLevel = 0;\n  let slots;\n  for (\n    let { slot, level } of\n    _objectValues(this._offspringMap).sort((a, b) => a.level - b.level)\n  ) {\n    if (level > currentLevel) {\n      slots = [];\n      this._offspringLevels.push(slots);\n      currentLevel = level;\n    }\n    slots.push(slot);\n  }\n  return this;\n};\n\n/**\n * touch a slot, that means, re-evaluate the slot's value forcely, and\n * starts *mutation process* and call change callbacks if neccessary.\n * usually, you don't need call this method, only when you need to mutate the\n * following graph (like override, replaceFollowing, follow)\n *\n * @param propogate - if starts a *mutation process*, default is true\n * @param context - if null, the touched slot is served as roots, default is null\n * @param callChangeCbs - if call change callbacks, default is true\n *\n * @return {boolean} - return true if this Slot is mutated, else false\n *\n * @see Slot#override\n * */\nSlot.prototype.touch = function (propogate=true, context=null, callChangeCbs=true) {\n  let oldValue = this._value;\n  if (!context) {\n    context = { roots: [this] };\n  }\n  if (this._valueFunc) {\n    let args = [\n      this._followings.map(following => following instanceof Slot? following.val(): following),\n      context,\n    ];\n    this._value = this._valueFunc.apply(this, args);\n  }\n  if (typeof this._mutationTester == 'function' && !this._mutationTester(oldValue, this._value)) {\n    return false;\n  }\n  if (callChangeCbs) {\n    for (let cb of this._changeCbs) {\n      cb.apply(this, [this._value, oldValue, context]);\n    }\n  }\n  propogate && this._propogate({ roots: context.roots });\n  return true;\n};\n\n/**\n * make a follower slot of me. this following has only one followings it is me.\n * @example\n * const $$s1 = Slot(1);\n * const $$s2 = $$s1.fork(n => n + 1);\n *\n * is equivalent to:\n *\n * @example\n * const $$s1 = Slot(1);\n * const $$s2 = Slot(([n]) => n + 1, [$$s1]);\n *\n * @param {function} func - the evaluation function\n * */\nSlot.prototype.fork = function (func) {\n  return Slot(function ([following]) {\n    return func(following);\n  }, [this]);\n};\n\n/**\n * unfollow all the followings if any and follow the new followings using the new\n * valueFunc, this method will mutate the following graph.\n *\n * !!NOTE this method will not re-evaluate the slot and starts the mutation process\n * at once, so remember to call touch at last if you want to start a mutaion process\n *\n * @param {function} valueFunc\n * @param {array} followings - please see Slot's constructor\n *\n * @return {Slot} this\n *\n * @see {@link Slot}\n * */\nSlot.prototype.follow = function (valueFunc, followings) {\n  // if connect to the same followings, nothing happens\n  let connectTheSameFollowings = true;\n  for (let i = 0; i < Math.max(followings.length, this._followings.length); ++i) {\n    if (followings[i] != this._followings[i]) {\n      connectTheSameFollowings = false;\n      break;\n    }\n  }\n  if (connectTheSameFollowings && (valueFunc == this._valueFunc)) {\n    return this;\n  }\n  let self = this;\n  // make my value invalid\n  self._value = void 0;\n  self._valueFunc = valueFunc;\n  // affected followings slots\n  let affected = {};\n  for (let slot of followings) {\n    if (slot instanceof Slot) {\n      affected[slot._id] = slot;\n    }\n  }\n  for (let following of self._followings) {\n    if (following instanceof Slot) {\n      if (followings.every(function (s) {\n        return s !== following;\n      })) {\n        affected[following._id] = following;\n        delete following._followerMap[self._id];\n      }\n    }\n  }\n  // setup followings\n  self._followings = [];\n  followings.forEach(function (slot) {\n    self._followings.push(slot);\n    if (slot instanceof Slot) {\n      slot._followerMap[self._id] = self;\n    }\n  });\n  // make ancestors' _offspringMap obsolete, it will be\n  // recalculated until they are evaluated\n  self._getAncestors().forEach(function (ancestor) {\n    ancestor._offspringLevels = ancestor._offspringMap = void 0;\n  });\n  return self;\n};\n\nSlot.prototype._getAncestors = function _getAncestors() {\n  let ancestors = {};\n  for (let following of this._followings) {\n    if (following instanceof Slot) {\n      if (!ancestors[following._id]) {\n        ancestors[following._id] = following;\n        for (let ancestor of following._getAncestors()) {\n          ancestors[ancestor._id] = ancestor;\n        }\n      }\n    }\n  }\n  return _objectValues(ancestors);\n};\n\n\n/**\n * shrink to a data slot with value *val*\n * @return {Slot} this\n * */\nSlot.prototype.shrink = function (val) {\n  this._valueFunc = void 0;\n  return this.follow(void 0, []).val(val);\n};\n\n\n/**\n * mutate a group of slots by applying functions upon them, and starts a\n * *mutation proccess* whose roots are these slots to be changed\n *\n * NOTE!!! this is not the same as set value for each slot one by one, but\n * consider them as a whole to find the best mutaion path\n *\n * @example\n * let $$p1 = Slot(1).tag('p1');\n * let $$p2 = Slot(2).tag('p2');\n * let $$p3 = $$p2.fork(it => it + 1).tag('p3');\n * let $$p4 = Slot(function ([p1, p2, p3], { roots, involved }) {\n *   console.log(roots.map(it => it.tag())); // p1, p2\n *   console.log(involved.map(it => it.tag())); // p1, p2, p3\n *   return p1 + p2 + p3;\n * }, [$$p1, $$p2, $$p3]);\n * rimple.mutateWith([\n *   [$$p1, n => n + 1],\n *   [$$p2, n => n + 2],\n * ]);\n * console.log($$p1.val(), $$p2.val(), $$p3.val(), $$p4.val()); // 2, 4, 5, 11\n *\n * @param {array} slotValuePairs - each element is an array, whose first value is\n * a Slot, and second is the function to be applied\n *\n * */\nexport const mutateWith = function mutateWith(slotFnPairs) {\n  return mutate(slotFnPairs.map(function ([slot, fn]) {\n    return [slot, fn && fn.apply(slot, [slot.val()])];\n  }));\n};\n\n/**\n * mutate a group of slots, and starts ONE *mutation proccess* whose\n * roots are these slots to be changed.\n *\n * NOTE!!! this is not the same as set value for each slot one by one, but\n * consider them as a whole to find the best mutaion path\n *\n * @example\n * let $$p1 = Slot(1).tag('p1');\n * let $$p2 = Slot(2).tag('p2');\n * let $$p3 = $$p2.fork(it => it + 1).tag('p3');\n * let $$p4 = Slot(function ([p1, p2, p3], { roots, involved }) {\n *   console.log(roots.map(it => it.tag())); // p1, p2\n *   console.log(involved.map(it => it.tag())); // p1, p2, p3\n *   return p1 + p2 + p3;\n * }, [$$p1, $$p2, $$p3]);\n * rimple.mutate([\n *   [$$p1, 2],\n *   [$$p2, 4],\n * ]);\n * console.log($$p1.val(), $$p2.val(), $$p3.val(), $$p4.val()); // 2, 4, 5, 11\n *\n * @param {array} slotValuePairs - each element is an array, whose first value is\n * a Slot, and second is the new value of slots\n *\n * */\nexport const mutate = function (slotValuePairs) {\n  let cleanSlots = {};\n  let roots = slotValuePairs.map(([slot]) => slot);\n  // mutate the targets directly\n  slotValuePairs.forEach(function ([slot, value]) {\n    slot.debug && console.info(`slot ${slot._tag} mutationTester`, slot._value, value);\n    let oldValue = slot._value;\n    if (value !== void 0) {\n      slot._value = value;\n      if (slot._mutationTester && !slot._mutationTester(oldValue, value)) {\n        cleanSlots[slot._id] = slot;\n        return;\n      }\n    }\n    for (let cb of slot._changeCbs) {\n      cb.call(slot, slot._value, oldValue, { roots });\n    }\n  });\n  // related slots include roots\n  let relatedSlots = {};\n  let addToRelatedSlots = function (slot, level) {\n    if (slot._id in relatedSlots) {\n      relatedSlots[slot._id].level = Math.max(\n        level, relatedSlots[slot._id].level\n      );\n    } else {\n      relatedSlots[slot._id] = {\n        slot,\n        level,\n      };\n    }\n  };\n  slotValuePairs.forEach(function ([slot]) {\n    addToRelatedSlots(slot, 0);\n    if (slot._offspringMap === void 0) {\n      slot._setupOffsprings();\n    }\n    _objectValues(slot._offspringMap).forEach(function ({slot: offspring, level}) {\n      addToRelatedSlots(offspring, level);\n    });\n  });\n  // group _offspringMap by level, but omits level 0 (those mutated directly)\n  // since they have been touched\n  let slots;\n  let levels = [];\n  let currentLevel = 0;\n  _objectValues(relatedSlots)\n  .sort((a, b) => a.level - b.level)\n  .filter(it => it.level > 0)\n  .forEach(function ({slot, level}) {\n    if (level > currentLevel) {\n      slots = [];\n      levels.push(slots);\n      currentLevel = level;\n    }\n    slots.push(slot);\n  });\n  let changeCbArgs = [];\n  for (let level of levels) {\n    for (let follower of level) {\n      let involved = follower._followings.filter(function (p) {\n        return p instanceof Slot && relatedSlots[p._id] && !cleanSlots[p._id];\n      });\n      if (!involved.length) {\n        cleanSlots[follower._id] = follower;\n        continue;\n      }\n      follower.debug && console.info(\n        `slot: slot ${follower._tag} will be refreshed`\n      );\n      let context = { involved, roots };\n      // DON'T use val(), val will reevaluate this slot\n      let oldV = follower._value;\n      // DON'T CALL change callbacks\n      if (follower.touch(false, context, false)) {\n        changeCbArgs.push([follower, oldV, involved]);\n      } else {\n        cleanSlots[follower._id] = follower;\n      }\n    }\n  }\n  // call change callbacks at last\n  changeCbArgs.forEach(function ([slot, oldV, involved]) {\n    for (let cb of slot._changeCbs) {\n      cb.apply(slot, [slot._value, oldV, { involved, roots }]);\n    }\n  });\n};\n\n/**\n * apply the function to me\n *\n * @example\n * const $$s = Slot(1);\n * $$s.mutateWith(function (s, n) {\n *  return s + n;\n * }, [2]);\n * console.log($$s.val()); // output 3\n *\n * is equivalent to\n * @example\n * const $$s = Slot(1);\n * $$s.val(function (s, n) { return s + n; }($$s.val(), 2));\n *\n * @param {function} func - the mutation function\n * @param {array} args - the extra arguments provided to func, default is []\n *\n * @return {Slot} this\n *\n * */\nSlot.prototype.mutateWith = function mutateWith(func, args=[]) {\n  args = [this._value].concat(args);\n  return this.val(func.apply(this, args));\n};\n\n/**\n * add methods to Slot's prototype\n *\n * @example\n * rimple.mixin({\n *   negate() {\n *     return this.val(-this.val());\n *   }\n * });\n * const $$s = Slot(1).negate();\n * console.log($$s.val()); // output -1\n *\n * @param {object} mixins - the mixins to be added\n *\n * */\nexport const mixin = function mixin(mixins) {\n  Object.assign(Slot.prototype, mixins);\n};\n\n/**\n * create an immutable slot, which use '===' to test if value is mutated\n * */\nexport const immSlot = function (value) {\n  return Slot(value).mutationTester(function (a, b) {\n    return a !== b;\n  });\n};\n\nmixin(booleanOps);\nmixin(objectOps);\nmixin(numberOps);\nmixin(listOps);\n\nexport const slot = Slot;\n"],"names":["val","patch","obj","debug","console","info","tag","Object","assign","keys","field","_value","prop","value","apply","Array","isArray","concat","path","o","i","length","seg","nextSeg","Number","isInteger","lastSeg","assoc","set","assocIn","setIn","numberOps","cnt","n","arr","fn","map","filter","slice","from","arguments","shift","unshift","push","pop","reverse","_uniqueId","prefix","_isEmptyObj","key","hasOwnProperty","_objectValues","values","Slot","args","_id","_changeCbs","_followings","_followerMap","_offspringMap","_offspringLevels","_tag","defineProperty","get","valueFunc","followings","eager","follow","prototype","isTopmost","v","mutationTester","tester","_mutationTester","change","proc","offChange","cb","clearChangeCbs","override","targetSlot","following","followerId","follower","_getAncestors","forEach","ancestor","replaceFollowing","idx","splice","replaced","removeFollowing","_propogate","roots","followers","touch","involved","_setupOffsprings","cleanSlots","mutateRoot","changeCbArgs","level","dirty","context","oldV","slot","_valueFunc","it","setV","newV","_colletFollowers","slots","ret","k","Math","max","currentLevel","sort","a","b","propogate","callChangeCbs","oldValue","fork","func","connectTheSameFollowings","self","every","s","ancestors","shrink","mutateWith","slotFnPairs","mutate","slotValuePairs","call","relatedSlots","addToRelatedSlots","offspring","levels","p","mixin","mixins","immSlot","booleanOps","objectOps","listOps"],"mappings":"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"}