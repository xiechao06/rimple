(function(a,b){'object'==typeof exports&&'undefined'!=typeof module?b(exports):'function'==typeof define&&define.amd?define('rimple',['exports'],b):b(a.rimple={})})(this,function(a){'use strict';/**
 * these are a group of operations to mutate a slot with value type of boolean
 *
 * @lends Slot.prototype
 *
 * */var b=Math.max,c={/**
   * patch the object value
   * @example
   * const $$s = $$({ name: 'Tom', color: 'Blue' });
   * $$s.patch({ name: 'Jerry', species: 'Mouse' });
   * console.log($$s.val()); // { name: 'Jerry', species: 'Mouse', colur: 'Blue' }
   *
   * @param {object} obj - object used to patch me
   * @return {Slot} this
   *
   * */patch:function(a){return this.debug&&console.info('slot: slot '+this.tag()+' is about to be patched',a),this.val(Object.assign({},this.val(),a))},/**
   * omit the keys
   * @example
   * const $$s = $$({ name: 'Tom', color: 'Blue' });
   * $$s.omit(['color']);
   * console.log($$s.val(); // { name: 'Tom' }
   *
   * @return {Slot} this
   * */omit:function(a){var b,c=!0,d=!1;try{for(var e,f,g=a[Symbol.iterator]();!(c=(e=g.next()).done);c=!0)f=e.value,delete this._value[f]}catch(a){d=!0,b=a}finally{try{!c&&g.return&&g.return()}finally{if(d)throw b}}return this.val(Object.assign({},this._value))},/**
   * set the property of Slot's value
   * @example
   * const $$s = $$({ name: 'Tom', color: 'Red' });
   * $$s.set('color', 'Blue');
   * console.log($$s.val(); // { name: 'Tom', color: 'Red' }
   *
   * @return {Slot} this
   * */set:function(a,b){return'function'==typeof b&&(b=b.apply(this,[this._value[a]])),this._value[a]=b,this.val(Array.isArray(this._value)?[].concat(this._value):Object.assign({},this._value)),this},/**
   * set the deep property of Slot's value
   * @example
   * const $$s = $$({ name: 'Tom' });
   * $$s.setIn(['friend', 'name'], 'Jerry');
   * console.log($$s.val(); // { name: 'Tom', frien: { 'name': 'Red'} }
   *
   * @example
   * const s = slot({});
   * s.setIn(['a', 1], 'abc'); // { a: [, 'abc'] }
   *
   * @return {Slot} this
   * */setIn:function(a,b){for(var c=this._value,d=0;d<a.length-1;++d){var e=a[d],f=a[d+1];c[e]=c[e]||(Number.isInteger(f)?[]:{}),c=c[e]}var g=a[a.length-1];return'function'==typeof b&&(b=b.apply(this,[c[g]])),c[g]=b,this.val(Object.assign({},this._value)),this}};/**
 * these are a group of operations to mutate a slot with value type of Object
 *
 * @lends Slot.prototype
 *
 * */c.assoc=c.set,c.assocIn=c.setIn;/**
 * these are a group of operations to mutate a slot with value type of number
 *
 * @lends Slot.prototype
 *
 * */var d=function(){function a(a,b){var c,d=[],e=!0,f=!1;try{for(var g,h=a[Symbol.iterator]();!(e=(g=h.next()).done)&&(d.push(g.value),!(b&&d.length===b));e=!0);}catch(a){f=!0,c=a}finally{try{!e&&h['return']&&h['return']()}finally{if(f)throw c}}return d}return function(b,c){if(Array.isArray(b))return b;if(Symbol.iterator in Object(b))return a(b,c);throw new TypeError('Invalid attempt to destructure non-iterable instance')}}(),e=function(){var a=1;return function(){var b=0<arguments.length&&arguments[0]!==void 0?arguments[0]:'';return b+a++}}(),f=function(a){for(var b in a)if(a.hasOwnProperty(b))return!1;return!0},g=function(a){if(Object.values)return Object.values(a);var b=[];for(var c in a)a.hasOwnProperty(c)&&b.push(a[c]);return b},h=function a(){for(var b=arguments.length,c=Array(b),d=0;d<b;d++)c[d]=arguments[d];if(!(this instanceof a))return new(Function.prototype.bind.apply(a,[null].concat(c)));if(this._id=e(),this._changeCbs=[],this._followings=[],this._followerMap={},this._offspringMap={},this._offspringLevels=[],this._tag='',Object.defineProperty(this,'token',{get:function(){return this._tag+'-'+this._id}}),Object.defineProperty(this,'followings',{get:function(){return this._followings}}),Object.defineProperty(this,'followers',{get:function(){return g(this._followerMap)}}),1>=c.length)this._value=c[0];else{var f=c[0],h=c[1],i=c[2];this.follow(f,h,i)}};/**
 * these are a group of operations to mutate a slot with value type of array
 *
 * @lends Slot.prototype
 *
 * *//**
 * @constructor
 *
 * @desc A Slot could be created in 2 methods:
 *
 *  * new Slot(value)
 *
 *  this will make a data slot
 *
 *  * new Slot(valueFunc, followings)
 *
 *  this will make a follower slot, where followings is an Array.
 *  if the element (say *following*) in observables is a:
 *
 *    * Slot
 *
 *      if *following* changed, *follower* will be re-evaludated by executing *valueFunc*,
 *      following.val() will be used as valueFunc's argument.
 *      its new value is the return value of *valueFunc*, and change will be propogated to
 *      *follower*'s followers.
 *
 *    * not Slot
 *
 *      when *follower* is re-evaluated, following will be used as *valueFunc*'s argument directly.
 *
 *  and valueFunc will accept 2 parameters:
 *
 *    * the current value of observables
 *    * mutation process context, it has two keys:
 *
 *      * roots - the mutation process roots, namely, those changed by clients (api caller)
 *        directly
 *
 *      * involved - the observed involed in this mutation process
 *
 *      the context is very useful if the evaluation function needs to return value
 *      according to which of its followings mutated
 *
 *  let's see two example:
 *
 *  ```javascript
 *
 *  const $$following = Slot(1);
 *  const $$follower = Slot((following, n) => following + n, [$$following, 2]);
 *  console.log($$follower.val()); // output 3, since n is always 2
 *
 *  $$following.inc();
 *  console.log($$follower.val()); // output 4, since n is always 2
 *  ```
 *
 *  ```javascript
 *
 *  const $$a = Slot(1).tag('a');
 *  const $$b = Slot(([a]) => a + 1, [$$a]).tag('b');
 *  const $$c = Slot(2).tag('c');
 *  const $$d = Slot(function ([a, b], {roots, involved}) {
 *    console.log(roots.map(it => it.tag())); // output [a]
 *    console.log(involved.map(it => it.tag())); // output [b]
 *    return a + b;
 *  });
 *
 *  // a is root of mutation proccess, and c is not changed in this mutation proccess
 *  $$a.inc();
 *
 *  ```
 *
 * *//**
 * test if slot observes others
 * @return {boolean} true if it observes others, else false
 * */h.prototype.isTopmost=function(){return!this._followings.length},h.prototype.tag=function(a){return void 0==a?this._tag:(this._tag=a,this)},h.prototype.mutationTester=function(a){return this._mutationTester=a,this},h.prototype.change=function(a){return this._changeCbs.push(a),this},h.prototype.offChange=function(a){this._changeCbs=this._changeCbs.filter(function(b){return b!=a})},h.prototype.override=function(a){var b,c=!0,d=!1;try{for(var e,f,g=a._followings[Symbol.iterator]();!(c=(e=g.next()).done);c=!0)f=e.value,delete f._followerMap[a._id]}catch(a){d=!0,b=a}finally{try{!c&&g.return&&g.return()}finally{if(d)throw b}}for(var h in a._followerMap){var j=a._followerMap[h];this._followerMap[h]=j;for(var k=0;k<j._followings.length;++k)if(j._followings[k]._id==a._id){j._followings[k]=this;break}}return this._offspringMap=this._offspringLevels=void 0,a._getAncestors().forEach(function(a){a._offspringLevels=a._offspringMap=void 0}),this},h.prototype.replaceFollowing=function(a,b){var c=[a,1];void 0!=b&&c.push(b);var e=this.followings.splice.apply(this.followings,c),f=d(e,1),g=f[0];// replace the same following, just return
return g==b?this:(g instanceof h&&(delete g._followerMap[this._id],g._offspringLevels=g._offspringMap=void 0,g._getAncestors().forEach(function(a){a._offspringLevels=a._offspringMap=void 0})),b instanceof h&&(b._offspringLevels=b._offspringMap=void 0,b._getAncestors().forEach(function(a){a._offspringLevels=a._offspringMap=void 0})),this)},h.prototype.removeFollowing=function(a){return this.replaceFollowing(a)},h.prototype._propogate=function(a){var b=a.roots,c=g(this._followerMap);// if has only one follower, touch it
if(0!=c.length){if(1==c.length)return void c[0].touch(!0,{roots:b,involved:[this]});(void 0===this._offspringLevels||void 0===this._offspringMap)&&this._setupOffsprings();var e,f={},i=this,j=[],k=!0,l=!1;// mutate root is always considered to be dirty,
// otherwise it won't propogate
try{for(var m,n=this._offspringLevels[Symbol.iterator]();!(k=(m=n.next()).done);k=!0){var o=m.value,p=!0,q=!1,r=void 0;try{for(var s,t=o[Symbol.iterator]();!(p=(s=t.next()).done);p=!0){var u=s.value,v=u._followings.filter(function(a){return a instanceof h&&(a._id===i._id||i._offspringMap[a._id]&&!f[a._id])}),w=0<v.length;// clean follower will be untouched
if(!w){f[u._id]=u;continue}u.debug&&console.info('slot: slot '+u._tag+' will be refreshed');var x=u._value;u.touch(!1,{involved:v,roots:b},!1)?j.push([u,x,v]):f[u._id]=u}}catch(a){q=!0,r=a}finally{try{!p&&t.return&&t.return()}finally{if(q)throw r}}}// call change callbacks at last
}catch(a){l=!0,e=a}finally{try{!k&&n.return&&n.return()}finally{if(l)throw e}}j.forEach(function(a){var c,e=d(a,3),f=e[0],g=e[1],h=e[2],i=!0,j=!1;try{for(var k,l,m=f._changeCbs[Symbol.iterator]();!(i=(k=m.next()).done);i=!0)l=k.value,l.apply(f,[f._value,g,{involved:h,roots:b}])}catch(a){j=!0,c=a}finally{try{!i&&m.return&&m.return()}finally{if(j)throw c}}})}},h.prototype.val=function(){return 0===arguments.length?(void 0===this._value&&'function'==typeof this._valueFunc&&(this._value=this._valueFunc.apply(this,[this._followings.map(function(a){return a instanceof h?a.val():a}),{roots:[this]}])),this._value):this.setV(0>=arguments.length?void 0:arguments[0])},h.prototype.setV=function(a){if('function'==typeof this._mutationTester&&!this._mutationTester(this._value,a))return this;this.debug&&console.info('slot: slot '+this._tag+' mutated -- ',this._value,'->',a);var b=this._value;this._value=a,this._propogate({roots:[this]});var c,d=!0,e=!1;try{for(var f,g,h=this._changeCbs[Symbol.iterator]();!(d=(f=h.next()).done);d=!0)g=f.value,g.apply(this,[this._value,b,{roots:[this]}])}catch(a){e=!0,c=a}finally{try{!d&&h.return&&h.return()}finally{if(e)throw c}}return this};var j=function(a){var b,c={},d=!0,e=!1;try{for(var f,h,i=a[Symbol.iterator]();!(d=(f=i.next()).done);d=!0)for(var j in h=f.value,h._followerMap){var k=h._followerMap[j];c[k._id]=k}}catch(a){e=!0,b=a}finally{try{!d&&i.return&&i.return()}finally{if(e)throw b}}return g(c)};h.prototype._setupOffsprings=function(){if(this._offspringMap={},this._offspringLevels=[],f(this._followerMap))return this;// level by level
for(var a=g(this._followerMap),c=1;a.length;a=j(a),++c){var d=!0,e=!1,h=void 0;try{for(var k,l,m=a[Symbol.iterator]();!(d=(k=m.next()).done);d=!0)l=k.value,l._id in this._offspringMap?this._offspringMap[l._id].level=b(this._offspringMap[l._id].level,c):this._offspringMap[l._id]={slot:l,level:c}}catch(a){e=!0,h=a}finally{try{!d&&m.return&&m.return()}finally{if(e)throw h}}}var n,o,p=0,q=!0,r=!1;try{for(var s,t=g(this._offspringMap).sort(function(c,a){return c.level-a.level})[Symbol.iterator]();!(q=(s=t.next()).done);q=!0){var u=s.value,v=u.slot,w=u.level;w>p&&(n=[],this._offspringLevels.push(n),p=w),n.push(v)}}catch(a){r=!0,o=a}finally{try{!q&&t.return&&t.return()}finally{if(r)throw o}}return this},h.prototype.touch=function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:!0,b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:null,c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:!0,d=this._value;if(b||(b={roots:[this]}),this._valueFunc){var e=[this._followings.map(function(a){return a instanceof h?a.val():a}),b];this._value=this._valueFunc.apply(this,e)}if('function'==typeof this._mutationTester&&!this._mutationTester(d,this._value))return!1;if(c){var f,g=!0,i=!1;try{for(var j,k,l=this._changeCbs[Symbol.iterator]();!(g=(j=l.next()).done);g=!0)k=j.value,k.apply(this,[this._value,d,b])}catch(a){i=!0,f=a}finally{try{!g&&l.return&&l.return()}finally{if(i)throw f}}}return a&&this._propogate({roots:b.roots}),!0},h.prototype.fork=function(a){return h(function(b){var c=d(b,1),e=c[0];return a(e)},[this])},h.prototype.follow=function(a,c){for(var d=!0,e=0;e<b(c.length,this._followings.length);++e)if(c[e]!=this._followings[e]){d=!1;break}// if connect to the same followings, nothing happens
if(d&&a==this._valueFunc)return this;var f=this;// make my value invalid
f._value=void 0,f._valueFunc=a;// affected followings slots
var g,i=!0,j=!1;try{for(var k,l=c[Symbol.iterator]();!(i=(k=l.next()).done);i=!0);}catch(a){j=!0,g=a}finally{try{!i&&l.return&&l.return()}finally{if(j)throw g}}var m,n=function(a){a instanceof h&&c.every(function(b){return b!==a})&&delete a._followerMap[f._id]},o=!0,p=!1;try{for(var q,r,s=f._followings[Symbol.iterator]();!(o=(q=s.next()).done);o=!0)r=q.value,n(r);// setup followings
}catch(a){p=!0,m=a}finally{try{!o&&s.return&&s.return()}finally{if(p)throw m}}return f._followings=[],c.forEach(function(a){f._followings.push(a),a instanceof h&&(a._followerMap[f._id]=f)}),f._getAncestors().forEach(function(a){a._offspringLevels=a._offspringMap=void 0}),f},h.prototype._getAncestors=function(){var a,b={},c=!0,d=!1;try{for(var e,f,i=this._followings[Symbol.iterator]();!(c=(e=i.next()).done);c=!0)if(f=e.value,f instanceof h&&!b[f._id]){b[f._id]=f;var j=!0,k=!1,l=void 0;try{for(var m,n,o=f._getAncestors()[Symbol.iterator]();!(j=(m=o.next()).done);j=!0)n=m.value,b[n._id]=n}catch(a){k=!0,l=a}finally{try{!j&&o.return&&o.return()}finally{if(k)throw l}}}}catch(b){d=!0,a=b}finally{try{!c&&i.return&&i.return()}finally{if(d)throw a}}return g(b)},h.prototype.shrink=function(a){return this._valueFunc=void 0,this.follow(void 0,[]).val(a)};/**
 * mutate a group of slots by applying functions upon them, and starts a
 * *mutation proccess* whose roots are these slots to be changed
 *
 * NOTE!!! this is not the same as set value for each slot one by one, but
 * consider them as a whole to find the best mutaion path
 *
 * @example
 * let $$p1 = Slot(1).tag('p1');
 * let $$p2 = Slot(2).tag('p2');
 * let $$p3 = $$p2.fork(it => it + 1).tag('p3');
 * let $$p4 = Slot(function ([p1, p2, p3], { roots, involved }) {
 *   console.log(roots.map(it => it.tag())); // p1, p2
 *   console.log(involved.map(it => it.tag())); // p1, p2, p3
 *   return p1 + p2 + p3;
 * }, [$$p1, $$p2, $$p3]);
 * rimple.mutateWith([
 *   [$$p1, n => n + 1],
 *   [$$p2, n => n + 2],
 * ]);
 * console.log($$p1.val(), $$p2.val(), $$p3.val(), $$p4.val()); // 2, 4, 5, 11
 *
 * @param {array} slotValuePairs - each element is an array, whose first value is
 * a Slot, and second is the function to be applied
 *
 * */var i=function(a){var c={},e=a.map(function(a){var b=d(a,1),c=b[0];return c});// mutate the targets directly
a.forEach(function(a){var b=d(a,2),f=b[0],g=b[1];f.debug&&console.info('slot '+f._tag+' mutationTester',f._value,g);var h=f._value;if(void 0!==g&&(f._value=g,f._mutationTester&&!f._mutationTester(h,g)))return void(c[f._id]=f);var i,j=!0,k=!1;try{for(var l,m,n=f._changeCbs[Symbol.iterator]();!(j=(l=n.next()).done);j=!0)m=l.value,m.call(f,f._value,h,{roots:e})}catch(a){k=!0,i=a}finally{try{!j&&n.return&&n.return()}finally{if(k)throw i}}});// related slots include roots
var f={},i=function(a,c){a._id in f?f[a._id].level=b(c,f[a._id].level):f[a._id]={slot:a,level:c}};a.forEach(function(a){var b=d(a,1),c=b[0];i(c,0),void 0===c._offspringMap&&c._setupOffsprings(),g(c._offspringMap).forEach(function(a){var b=a.slot,c=a.level;i(b,c)})});// group _offspringMap by level, but omits level 0 (those mutated directly)
// since they have been touched
var j,k=[],l=0;g(f).sort(function(c,a){return c.level-a.level}).filter(function(a){return 0<a.level}).forEach(function(a){var b=a.slot,c=a.level;c>l&&(j=[],k.push(j),l=c),j.push(b)});var m,n=[],o=!0,p=!1;try{for(var q,r=k[Symbol.iterator]();!(o=(q=r.next()).done);o=!0){var s=q.value,t=!0,u=!1,v=void 0;try{for(var w,x=s[Symbol.iterator]();!(t=(w=x.next()).done);t=!0){var y=w.value,z=y._followings.filter(function(a){return a instanceof h&&f[a._id]&&!c[a._id]});if(!z.length){c[y._id]=y;continue}y.debug&&console.info('slot: slot '+y._tag+' will be refreshed');var A=y._value;// DON'T use val(), val will reevaluate this slot
// DON'T CALL change callbacks
y.touch(!1,{involved:z,roots:e},!1)?n.push([y,A,z]):c[y._id]=y}}catch(a){u=!0,v=a}finally{try{!t&&x.return&&x.return()}finally{if(u)throw v}}}// call change callbacks at last
}catch(a){p=!0,m=a}finally{try{!o&&r.return&&r.return()}finally{if(p)throw m}}n.forEach(function(a){var b,c=d(a,3),f=c[0],g=c[1],h=c[2],i=!0,j=!1;try{for(var k,l,m=f._changeCbs[Symbol.iterator]();!(i=(k=m.next()).done);i=!0)l=k.value,l.apply(f,[f._value,g,{involved:h,roots:e}])}catch(a){j=!0,b=a}finally{try{!i&&m.return&&m.return()}finally{if(j)throw b}}})};/**
 * mutate a group of slots, and starts ONE *mutation proccess* whose
 * roots are these slots to be changed.
 *
 * NOTE!!! this is not the same as set value for each slot one by one, but
 * consider them as a whole to find the best mutaion path
 *
 * @example
 * let $$p1 = Slot(1).tag('p1');
 * let $$p2 = Slot(2).tag('p2');
 * let $$p3 = $$p2.fork(it => it + 1).tag('p3');
 * let $$p4 = Slot(function ([p1, p2, p3], { roots, involved }) {
 *   console.log(roots.map(it => it.tag())); // p1, p2
 *   console.log(involved.map(it => it.tag())); // p1, p2, p3
 *   return p1 + p2 + p3;
 * }, [$$p1, $$p2, $$p3]);
 * rimple.mutate([
 *   [$$p1, 2],
 *   [$$p2, 4],
 * ]);
 * console.log($$p1.val(), $$p2.val(), $$p3.val(), $$p4.val()); // 2, 4, 5, 11
 *
 * @param {array} slotValuePairs - each element is an array, whose first value is
 * a Slot, and second is the new value of slots
 *
 * *//**
 * apply the function to me
 *
 * @example
 * const $$s = Slot(1);
 * $$s.mutateWith(function (s, n) {
 *  return s + n;
 * }, [2]);
 * console.log($$s.val()); // output 3
 *
 * is equivalent to
 * @example
 * const $$s = Slot(1);
 * $$s.val(function (s, n) { return s + n; }($$s.val(), 2));
 *
 * @param {function} func - the mutation function
 * @param {array} args - the extra arguments provided to func, default is []
 *
 * @return {Slot} this
 *
 * */h.prototype.mutateWith=function(a){var b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:[];return b=[this._value].concat(b),this.val(a.apply(this,b))};/**
 * add methods to Slot's prototype
 *
 * @example
 * rimple.mixin({
 *   negate() {
 *     return this.val(-this.val());
 *   }
 * });
 * const $$s = Slot(1).negate();
 * console.log($$s.val()); // output -1
 *
 * @param {object} mixins - the mixins to be added
 *
 * */var k=function(a){Object.assign(h.prototype,a)};/**
 * create an immutable slot, which use '===' to test if value is mutated
 * */k({/**
   * toggle the Slot's value
   * @return {Slot} this
   * */toggle:function(){return this.val(!this.val())},/**
   * make the Slot's value to be true
   * @return {Slot} this
   * */on:function(){return this.val(!0)},/**
   * make the Slot's value to be false
   * @return {Slot} this
   * */off:function(){return this.val(!1)}}),k(c),k({/**
   * increment the slot's value, the slot's value should be of type number
   *
   * @param {number} cnt - the value to be added, default is 1
   * @return {Slot} this
   * */inc:function(){var a=0<arguments.length&&arguments[0]!==void 0?arguments[0]:1;return this.val(this.val()+a)},/**
   * decrement the slot's value, the slot's value should be of type number
   *
   * @param {number} cnt - the value to be deremented, default is 1
   * @return {Slot} this
   * */dec:function(){var a=0<arguments.length&&arguments[0]!==void 0?arguments[0]:1;return this.val(this.val()-a)},/**
   * get remainder the slot's value, the slot's value should be of type number
   *
   * @example
   * const $$s = $$(17).mod(7);
   * console.log($$s.val());  // output 3
   *
   * @param {number} n - the divisor
   * @return {Slot} this
   * */mod:function(a){return this.val(this.val()%a)},/**
   * multiply the slot's value by n, the slot's value should be of type number
   *
   * @param {number} n - the multiplier
   * @return {Slot} this
   * */multiply:function(a){return this.val(this.val()*a)},/**
   * divides the slot's value by n, the slot's value should be of type number
   *
   * @param {number} n - the divisor
   * @return {Slot} this
   * */divide:function(a){return this.val(this.val()/a)}}),k({/**
   * concat the Slot's value with an array
   *
   * @param {array} arr
   * @return {Slot} this
   * */concat:function(a){return this.val([].concat(this.val()).concat(a))},/**
   * map the Slot's value with a function
   *
   * @example
   * const $$s = $$([1, 2, 3]);
   * console.log($$s.map(it => it * 2).val()); // 2, 4, 6
   *
   * @param {function} fn
   * @return {Slot} this
   * */map:function(a){return this.val(this.val().map(a))},/**
   * filter the Slot's value with a function
   *
   * @example
   * const $$s = $$([1, 2, 3, 4]);
   * console.log($$s.filter(it => it % 2 == 0).val()); // 2, 4
   *
   * @param {function} fn
   * @return {Slot} this
   * */filter:function(a){var b=this.val();return this.val(b.filter(a))},/**
   * slice the Slot's value
   *
   * @example
   * const $$s = $$([1, 2, 3, 4]);
   * console.log($$s.slice(1, 2).val()); // [2]
   *
   * @return {Slot} this
   * */slice:function(){var a=this.val();return this.val(a.slice.apply(a,Array.from(arguments)))},/**
   * shift the Slot's value
   *
   * @example
   * const $$s = $$([1, 2, 3, 4]);
   * console.log($$s.shift().val()); // 2, 3, 4
   *
   * @return {Slot} this
   * */shift:function(){return this.val().shift(),this.val([].concat(this.val())),this},/**
   * shift the Slot's value
   *
   * @example
   * const $$s = $$([2, 3, 4]);
   * console.log($$s.unshift(1).val()); // 1, 2, 3, 4
   *
   * @return {Slot} this
   * */unshift:function(a){return this.val().unshift(a),this.val([].concat(this.val())),this},/**
   * push the Slot's value
   *
   * @example
   * const $$s = $$([1, 2, 3]);
   * console.log($$s.push(4).val()); // 1, 2, 3, 4
   *
   * @return {Slot} this
   * */push:function(a){return this.val().push(a),this.val([].concat(this.val())),this},/**
   * push the Slot's value
   *
   * @example
   * const $$s = $$([1, 2, 3]);
   * console.log($$s.pop().val()); // 1, 2
   *
   * @return {Slot} this
   * */pop:function(){return this.val().pop(),this.val([].concat(this.val())),this},/**
   * reverse the Slot's value
   *
   * @example
   * const $$s = $$([1, 2, 3]);
   * console.log($$s.pop().val()); // [3, 2, 1]
   *
   * @return {Slot} this
   * */reverse:function(){return this.val([].concat(this.val().reverse())),this}});a.Slot=h,a.mutateWith=function(a){return i(a.map(function(a){var b=d(a,2),c=b[0],e=b[1];return[c,e&&e.apply(c,[c.val()])]}))},a.mutate=i,a.mixin=k,a.immSlot=function(a){return h(a).mutationTester(function(c,a){return c!==a})},a.slot=h,Object.defineProperty(a,'__esModule',{value:!0})});

//# sourceMappingURL=rimple.min.js.map
