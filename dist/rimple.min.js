(function(a,b){'object'==typeof exports&&'undefined'!=typeof module?module.exports=b():'function'==typeof define&&define.amd?define('rimple',b):a.rimple=b()})(this,function(){'use strict';/**
 * these are a group of operations to mutate a slot with value type of boolean
 *
 * @lends Slot.prototype
 *
 * */var a=Math.max,b=function(){function a(a,b){var c,d=[],e=!0,f=!1;try{for(var g,h=a[Symbol.iterator]();!(e=(g=h.next()).done)&&(d.push(g.value),!(b&&d.length===b));e=!0);}catch(a){f=!0,c=a}finally{try{!e&&h['return']&&h['return']()}finally{if(f)throw c}}return d}return function(b,c){if(Array.isArray(b))return b;if(Symbol.iterator in Object(b))return a(b,c);throw new TypeError('Invalid attempt to destructure non-iterable instance')}}(),c=function(){var a=1;return function(){var b=0<arguments.length&&void 0!==arguments[0]?arguments[0]:'';return b+a++}}(),d=function(a){for(var b in a)if(a.hasOwnProperty(b))return!1;return!0},e=function(a){if(Object.values)return Object.values(a);var b=[];for(var c in a)a.hasOwnProperty(c)&&b.push(a[c]);return b},f=function a(){for(var b=arguments.length,d=Array(b),f=0;f<b;f++)d[f]=arguments[f];if(!(this instanceof a))return new(Function.prototype.bind.apply(a,[null].concat(d)));if(this._id=c(),this._changeCbs=[],this._followings=[],this._followerMap={},this._offspringMap={},this._offspringLevels=[],this._tag='',Object.defineProperty(this,'token',{get:function(){return this._tag+'-'+this._id}}),Object.defineProperty(this,'followings',{get:function(){return this._followings}}),Object.defineProperty(this,'followers',{get:function(){return e(this._followerMaps)}}),1>=d.length)this._value=d[0];else{var g=d[0],h=d[1],i=d[2];this.follow(g,h,i)}};/**
 * these are a group of operations to mutate a slot with value type of Object
 *
 * @lends Slot.prototype
 *
 * *//**
 * these are a group of operations to mutate a slot with value type of number
 *
 * @lends Slot.prototype
 *
 * *//**
 * these are a group of operations to mutate a slot with value type of array
 *
 * @lends Slot.prototype
 *
 * *//**
 * @constructor
 *
 * @desc A Slot could be created in 2 methods:
 *
 *  * new Slot(value)
 *
 *  this will make a data slot
 *
 *  * new Slot(valueFunc, followings)
 *
 *  this will make a follower slot, where followings is an Array.
 *  if the element (say *following*) in observables is a:
 *
 *    * Slot
 *
 *      if *following* changed, *follower* will be re-evaludated by executing *valueFunc*,
 *      following.val() will be used as valueFunc's argument.
 *      its new value is the return value of *valueFunc*, and change will be propogated to
 *      *follower*'s followers.
 *
 *    * not Slot
 *
 *      when *follower* is re-evaluated, following will be used as *valueFunc*'s argument directly.
 *
 *  and valueFunc will accept 2 parameters:
 *
 *    * the current value of observables
 *    * mutation process context, it has two keys:
 *
 *      * roots - the mutation process roots, namely, those changed by clients (api caller)
 *        directly
 *
 *      * involved - the observed involed in this mutation process
 *
 *      the context is very useful if the evaluation function needs to return value
 *      according to which of its followings mutated
 *
 *  let's see two example:
 *
 *  ```javascript
 *
 *  const $$following = $$(1);
 *  const $$follower = $$((following, n) => following + n, [$$following, 2]);
 *  console.log($$follower.val()); // output 3, since n is always 2
 *
 *  $$following.inc();
 *  console.log($$follower.val()); // output 4, since n is always 2
 *  ```
 *
 *  ```javascript
 *
 *  const $$a = $$(1).tag('a');
 *  const $$b = $$(([a]) => a + 1, [$$a]).tag('b');
 *  const $$c = $$(2).tag('c');
 *  const $$d = $$(function ([a, b], {roots, involved}) {
 *    console.log(roots.map(it => it.tag())); // output [a]
 *    console.log(involved.map(it => it.tag())); // output [b]
 *    return a + b;
 *  });
 *
 *  // a is root of mutation proccess, and c is not changed in this mutation proccess
 *  $$a.inc();
 *
 *  ```
 *
 * *//**
 * test if slot observes others
 * @return {boolean} true if it observes others, else false
 * */f.prototype.isTopmost=function(){return!this._followings.length},f.prototype.tag=function(a){return void 0==a?this._tag:(this._tag=a,this)},f.prototype.mutationTester=function(a){return this._mutationTester=a,this},f.prototype.change=function(a){return this._changeCbs.push(a),this},f.prototype.offChange=function(a){this._changeCbs=this._changeCbs.filter(function(b){return b!=a})},f.prototype.override=function(a){var b,c=!0,d=!1;try{for(var e,f,g=a._followings[Symbol.iterator]();!(c=(e=g.next()).done);c=!0)f=e.value,delete f._followerMap[a._id]}catch(a){d=!0,b=a}finally{try{!c&&g.return&&g.return()}finally{if(d)throw b}}for(var h in a._followerMap){var j=a._followerMap[h];this._followerMap[h]=j;for(var k=0;k<j._followings.length;++k)if(j._followings[k]._id==a._id){j._followings[k]=this;break}}return this._offspringMap=this._offspringLevels=void 0,a._getAncestors().forEach(function(a){a._offspringLevels=a._offspringMap=void 0}),this},f.prototype.replaceFollowing=function(a,c){var d=[a,1];void 0!=c&&d.push(c);var e=this.followings.splice.apply(this.followings,d),g=b(e,1),h=g[0];// replace the same following, just return
return h==c?this:(h instanceof f&&(delete h._followerMap[this.id],h._offspringLevels=h._offspringMap=void 0,h._getAncestors().forEach(function(a){a._offspringLevels=a._offspringMap=void 0})),c instanceof f&&(c._offspringLevels=c._offspringMap=void 0,c._getAncestors().forEach(function(a){a._offspringLevels=a._offspringMap=void 0})),this)},f.prototype.removeFollowing=function(a){return this.replaceFollowing(a)},f.prototype._propogate=function(a){var c=a.roots,d=e(this._followerMap);// if has only one follower, touch it
if(0!=d.length){if(1==d.length)return void d[0].touch(!0,{roots:c,involved:[this]});(void 0===this._offspringLevels||void 0===this._offspringMap)&&this._setupOffsprings();var g,h={},i=this,j=[],k=!0,l=!1;// mutate root is always considered to be dirty,
// otherwise it won't propogate
try{for(var m,n=this._offspringLevels[Symbol.iterator]();!(k=(m=n.next()).done);k=!0){var o=m.value,p=!0,q=!1,r=void 0;try{for(var s,t=o[Symbol.iterator]();!(p=(s=t.next()).done);p=!0){var u=s.value,v=u._followings.filter(function(a){return a instanceof f&&(a._id===i._id||i._offspringMap[a._id]&&!h[a._id])}),w=0<v.length;// clean follower will be untouched
if(!w){h[u._id]=u;continue}u.debug&&console.info('slot: slot '+u._tag+' will be refreshed');var x=u._value;u.touch(!1,{involved:v,roots:c},!1)?j.push([u,x,v]):h[u._id]=u}}catch(a){q=!0,r=a}finally{try{!p&&t.return&&t.return()}finally{if(q)throw r}}}// call change callbacks at last
}catch(a){l=!0,g=a}finally{try{!k&&n.return&&n.return()}finally{if(l)throw g}}j.forEach(function(a){var d,e=b(a,3),f=e[0],g=e[1],h=e[2],i=!0,j=!1;try{for(var k,l,m=f._changeCbs[Symbol.iterator]();!(i=(k=m.next()).done);i=!0)l=k.value,l.apply(f,[f._value,g,{involved:h,roots:c}])}catch(a){j=!0,d=a}finally{try{!i&&m.return&&m.return()}finally{if(j)throw d}}})}},f.prototype.val=function(){return 0===arguments.length?(void 0===this._value&&'function'==typeof this._valueFunc&&(this._value=this._valueFunc.apply(this,[this._followings.map(function(a){return a instanceof f?a.val():a}),{roots:[this]}])),this._value):this.setV(0>=arguments.length?void 0:arguments[0])},f.prototype.setV=function(a){if('function'==typeof this._mutationTester&&!this._mutationTester(this.value,a))return this;this.debug&&console.info('slot: slot '+this._tag+' mutated -- ',this.value,'->',a);var b=this._value;this._value=a,this._propogate({roots:[this]});var c,d=!0,e=!1;try{for(var f,g,h=this._changeCbs[Symbol.iterator]();!(d=(f=h.next()).done);d=!0)g=f.value,g.apply(this,[this._value,b,{roots:[this]}])}catch(a){e=!0,c=a}finally{try{!d&&h.return&&h.return()}finally{if(e)throw c}}return this};var g=function(a){var b,c={},d=!0,f=!1;try{for(var g,h,i=a[Symbol.iterator]();!(d=(g=i.next()).done);d=!0)for(var j in h=g.value,h._followerMap){var k=h._followerMap[j];c[k._id]=k}}catch(a){f=!0,b=a}finally{try{!d&&i.return&&i.return()}finally{if(f)throw b}}return e(c)};f.prototype._setupOffsprings=function(){if(this._offspringMap={},this._offspringLevels=[],d(this._followerMap))return this;// level by level
for(var b=e(this._followerMap),c=1;b.length;b=g(b),++c){var f=!0,h=!1,j=void 0;try{for(var k,l,m=b[Symbol.iterator]();!(f=(k=m.next()).done);f=!0)l=k.value,l._id in this._offspringMap?this._offspringMap[l._id].level=a(this._offspringMap[l._id].level,c):this._offspringMap[l._id]={slot:l,level:c}}catch(a){h=!0,j=a}finally{try{!f&&m.return&&m.return()}finally{if(h)throw j}}}var n,o,p=0,q=!0,r=!1;try{for(var s,t=e(this._offspringMap).sort(function(c,a){return c.level-a.level})[Symbol.iterator]();!(q=(s=t.next()).done);q=!0){var u=s.value,v=u.slot,w=u.level;w>p&&(n=[],this._offspringLevels.push(n),p=w),n.push(v)}}catch(a){r=!0,o=a}finally{try{!q&&t.return&&t.return()}finally{if(r)throw o}}return this},f.prototype.touch=function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:!0,b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:null,c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:!0,d=this._value;if(b||(b={roots:[this]}),this._valueFunc){var e=[this._followings.map(function(a){return a instanceof f?a.val():a}),b];this._value=this._valueFunc.apply(this,e)}if('function'==typeof this._mutationTester&&!this._mutationTester(d,this._value))return!1;if(c){var g,h=!0,i=!1;try{for(var j,k,l=this._changeCbs[Symbol.iterator]();!(h=(j=l.next()).done);h=!0)k=j.value,k.apply(this,[this._value,d,b])}catch(a){i=!0,g=a}finally{try{!h&&l.return&&l.return()}finally{if(i)throw g}}}return a&&this._propogate({roots:b.roots}),!0},f.prototype.fork=function(a){return f(function(c){var d=b(c,1),e=d[0];return a(e)},[this])},f.prototype.follow=function(b,c){for(var d=!0,e=0;e<a(c.length,this._followings.length);++e)if(c[e]!=this._followings[e]){d=!1;break}// if connect to the same followings, nothing happens
if(d&&b==this._valueFunc)return this;var g=this;// make my value invalid
g._value=void 0,g._valueFunc=b;// affected followings slots
var h,i=!0,j=!1;try{for(var k,l=c[Symbol.iterator]();!(i=(k=l.next()).done);i=!0);}catch(a){j=!0,h=a}finally{try{!i&&l.return&&l.return()}finally{if(j)throw h}}var m,n=function(a){a instanceof f&&c.every(function(b){return b!==a})&&delete a._followerMap[g._id]},o=!0,p=!1;try{for(var q,r,s=g._followings[Symbol.iterator]();!(o=(q=s.next()).done);o=!0)r=q.value,n(r);// setup followings
}catch(a){p=!0,m=a}finally{try{!o&&s.return&&s.return()}finally{if(p)throw m}}return g._followings=[],c.forEach(function(a){g._followings.push(a),a instanceof f&&(a._followerMap[g._id]=g)}),g._getAncestors().forEach(function(a){a._offspringLevels=a._offspringMap=void 0}),g},f.prototype._getAncestors=function(){var a,b={},c=!0,d=!1;try{for(var g,h,i=this._followings[Symbol.iterator]();!(c=(g=i.next()).done);c=!0)if(h=g.value,h instanceof f&&!b[h._id]){b[h._id]=h;var j=!0,k=!1,l=void 0;try{for(var m,n,o=h._getAncestors()[Symbol.iterator]();!(j=(m=o.next()).done);j=!0)n=m.value,b[n._id]=n}catch(a){k=!0,l=a}finally{try{!j&&o.return&&o.return()}finally{if(k)throw l}}}}catch(b){d=!0,a=b}finally{try{!c&&i.return&&i.return()}finally{if(d)throw a}}return e(b)},f.prototype.shrink=function(a){return this._valueFunc=void 0,this.follow(void 0,[]).val(a)};/**
 * mutate a group of slots by applying functions upon them, and starts a
 * *mutation proccess* whose roots are these slots to be changed
 *
 * @example
 * let $$p1 = $$(1).tag('p1');
 * let $$p2 = $$(2).tag('p2');
 * let $$p3 = $$p2.fork(it => it + 1).tag('p3');
 * let $$p4 = $$(function ([p1, p2, p3], { roots, involved }) {
 *   console.log(roots.map(it => it.tag())); // p1, p2
 *   console.log(involved.map(it => it.tag())); // p1, p2, p3
 *   return p1 + p2 + p3;
 * }, [$$p1, $$p2, $$p3]);
 * $$.mutateWith([
 *   [$$p1, n => n + 1],
 *   [$$p2, n => n + 2],
 * ]);
 * console.log($$p1.val(), $$p2.val(), $$p3.val(), $$p4.val()); // 2, 4, 5, 11
 *
 * @param {array} slotValuePairs - each element is an array, whose first value is
 * a Slot, and second is the function to be applied
 *
 * */var h=function(c){var d={},g=c.map(function(a){var c=b(a,1),d=c[0];return d});// mutate the targets directly
c.forEach(function(a){var c=b(a,2),e=c[0],f=c[1];e.debug&&console.info('slot '+e._tag+' mutationTester',e._value,f);var h=e._value;if(void 0!==f&&(e._value=f,e._mutationTester&&!e._mutationTester(h,f)))return void(d[e._id]=e);var i,j=!0,k=!1;try{for(var l,m,n=e._changeCbs[Symbol.iterator]();!(j=(l=n.next()).done);j=!0)m=l.value,m.call(e,e._value,h,{roots:g})}catch(a){k=!0,i=a}finally{try{!j&&n.return&&n.return()}finally{if(k)throw i}}});// related slots include roots
var h={},i=function(b,c){b._id in h?h[b._id].level=a(c,h[b._id].level):h[b._id]={slot:b,level:c}};c.forEach(function(a){var c=b(a,1),d=c[0];i(d,0),void 0===d._offspringMap&&d._setupOffsprings(),e(d._offspringMap).forEach(function(a){var b=a.slot,c=a.level;i(b,c)})});// group _offspringMap by level, but omits level 0 (those mutated directly)
// since they have been touched
var j,k=[],l=0;e(h).sort(function(c,a){return c.level-a.level}).filter(function(a){return 0<a.level}).forEach(function(a){var b=a.slot,c=a.level;c>l&&(j=[],k.push(j),l=c),j.push(b)});var m,n=[],o=!0,p=!1;try{for(var q,r=k[Symbol.iterator]();!(o=(q=r.next()).done);o=!0){var s=q.value,t=!0,u=!1,v=void 0;try{for(var w,x=s[Symbol.iterator]();!(t=(w=x.next()).done);t=!0){var y=w.value,z=y._followings.filter(function(a){return a instanceof f&&h[a._id]&&!d[a._id]});if(!z.length){d[y._id]=y;continue}y.debug&&console.info('slot: slot '+y._tag+' will be refreshed');var A=y._value;// DON'T use val(), val will reevaluate this slot
// DON'T CALL change callbacks
y.touch(!1,{involved:z,roots:g},!1)?n.push([y,A,z]):d[y._id]=y}}catch(a){u=!0,v=a}finally{try{!t&&x.return&&x.return()}finally{if(u)throw v}}}// call change callbacks at last
}catch(a){p=!0,m=a}finally{try{!o&&r.return&&r.return()}finally{if(p)throw m}}n.forEach(function(a){var c,d=b(a,3),e=d[0],f=d[1],h=d[2],i=!0,j=!1;try{for(var k,l,m=e._changeCbs[Symbol.iterator]();!(i=(k=m.next()).done);i=!0)l=k.value,l.apply(e,[e._value,f,{involved:h,roots:g}])}catch(a){j=!0,c=a}finally{try{!i&&m.return&&m.return()}finally{if(j)throw c}}})};/**
 * mutate a group of slots, and starts a *mutation proccess* whose
 * roots are these slots to be changed
 *
 * @example
 * let $$p1 = $$(1).tag('p1');
 * let $$p2 = $$(2).tag('p2');
 * let $$p3 = $$p2.fork(it => it + 1).tag('p3');
 * let $$p4 = $$(function ([p1, p2, p3], { roots, involved }) {
 *   console.log(roots.map(it => it.tag())); // p1, p2
 *   console.log(involved.map(it => it.tag())); // p1, p2, p3
 *   return p1 + p2 + p3;
 * }, [$$p1, $$p2, $$p3]);
 * $$.mutate([
 *   [$$p1, 2],
 *   [$$p2, 4],
 * ]);
 * console.log($$p1.val(), $$p2.val(), $$p3.val(), $$p4.val()); // 2, 4, 5, 11
 *
 * @param {array} slotValuePairs - each element is an array, whose first value is
 * a Slot, and second is the new value of slots
 *
 * *//**
 * apply the function to me
 *
 * @example
 * const $$s = $$(1);
 * $$s.mutateWith(function (s, n) {
 *  return s + n;
 * }, [2]);
 * console.log($$s.val()); // output 3
 *
 * is equivalent to
 * @example
 * const $$s = $$(1);
 * $$s.val(function (s, n) { return s + n; }($$s.val(), 2));
 *
 * @param {function} func - the mutation function
 * @param {array} args - the extra arguments provided to func, default is []
 *
 * @return {Slot} this
 *
 * */f.prototype.mutateWith=function(a){var b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:[];return b=[this._value].concat(b),this.val(a.apply(this,b))};/**
 * add methods to Slot's prototype
 *
 * @example
 * $$.mixin({
 *   negate() {
 *     return this.val(-this.val());
 *   }
 * });
 * const $$s = $$(1).negate();
 * console.log($$s.val()); // output -1
 *
 * @param {object} mixins - the mixins to be added
 *
 * */var i=function(a){Object.assign(f.prototype,a)};i({/**
   * toggle the Slot's value
   * @return {Slot} this
   * */toggle:function(){return this.val(!this.val())},/**
   * make the Slot's value to be true
   * @return {Slot} this
   * */on:function(){return this.val(!0)},/**
   * make the Slot's value to be false
   * @return {Slot} this
   * */off:function(){return this.val(!1)}}),i({/**
   * patch the object value
   * @example
   * const $$s = $$({ name: 'Tom', color: 'Blue' });
   * $$s.patch({ name: 'Jerry', species: 'Mouse' });
   * console.log($$s.val()); // { name: 'Jerry', species: 'Mouse', colur: 'Blue' }
   *
   * @param {object} obj - object used to patch me
   * @return {Slot} this
   *
   * */patch:function(a){return this.debug&&console.info('slot: slot '+this.tag()+' is about to be patched',a),this.val(Object.assign(this.val(),a))},/**
   * omit the keys
   * @example
   * const $$s = $$({ name: 'Tom', color: 'Blue' });
   * $$s.omit(['color']);
   * console.log($$s.val(); // { name: 'Tom' }
   *
   * @return {Slot} this
   * */omit:function(a){var b,c=!0,d=!1;try{for(var e,f,g=a[Symbol.iterator]();!(c=(e=g.next()).done);c=!0)f=e.value,delete this._value[f]}catch(a){d=!0,b=a}finally{try{!c&&g.return&&g.return()}finally{if(d)throw b}}return this.val(this._value)},/**
   * set the property of Slot's value
   * @example
   * const $$s = $$({ name: 'Tom', color: 'Red' });
   * $$s.setProp('color', 'Blue');
   * console.log($$s.val(); // { name: 'Tom', color: 'Red' }
   *
   * @return {Slot} this
   * */setProp:function(a,b){return'function'==typeof b&&(b=b.apply(this,[this.value[a]])),this.value[a]=b,this.touch(),this},/**
   * set the deep property of Slot's value
   * @example
   * const $$s = $$({ name: 'Tom' });
   * $$s.setPath(['friend', 'name'], 'Jerry');
   * console.log($$s.val(); // { name: 'Tom', frien: { 'name': 'Red'} }
   *
   * @return {Slot} this
   * */setPath:function(a,b){var c,d=this.value,e=!0,f=!1;try{for(var g,h,i=a.slice(0,-1)[Symbol.iterator]();!(e=(g=i.next()).done);e=!0)h=g.value,d[h]=d[h]||{},d=d[h]}catch(a){f=!0,c=a}finally{try{!e&&i.return&&i.return()}finally{if(f)throw c}}var j=a[a.length-1];return'function'==typeof b&&(b=b.apply(this,[d[j]])),d[j]=b,this.touch(),this}}),i({/**
   * increment the slot's value, the slot's value should be of type number
   *
   * @param {number} cnt - the value to be added, default is 1
   * @return {Slot} this
   * */inc:function(){var a=0<arguments.length&&arguments[0]!==void 0?arguments[0]:1;return this.val(this.val()+a)},/**
   * decrement the slot's value, the slot's value should be of type number
   *
   * @param {number} cnt - the value to be deremented, default is 1
   * @return {Slot} this
   * */dec:function(){var a=0<arguments.length&&arguments[0]!==void 0?arguments[0]:1;return this.val(this.val()-a)},/**
   * get remainder the slot's value, the slot's value should be of type number
   *
   * @example
   * const $$s = $$(17).mod(7);
   * console.log($$s.val());  // output 3
   *
   * @param {number} n - the divisor
   * @return {Slot} this
   * */mod:function(a){return this.val(this.val()%a)},/**
   * multiply the slot's value by n, the slot's value should be of type number
   *
   * @param {number} n - the multiplier
   * @return {Slot} this
   * */multiply:function(a){return this.val(this.val()*a)},/**
   * divides the slot's value by n, the slot's value should be of type number
   *
   * @param {number} n - the divisor
   * @return {Slot} this
   * */divide:function(a){return this.val(this.val()/a)}}),i({/**
   * concat the Slot's value with an array
   *
   * @param {array} arr
   * @return {Slot} this
   * */concat:function(a){return this.val(this.val().concat(a))},/**
   * map the Slot's value with a function
   *
   * @example
   * const $$s = $$([1, 2, 3]);
   * console.log($$s.map(it => it * 2).val()); // 2, 4, 6
   *
   * @param {function} fn
   * @return {Slot} this
   * */map:function(a){return this.val(this.val().map(a))},/**
   * filter the Slot's value with a function
   *
   * @example
   * const $$s = $$([1, 2, 3, 4]);
   * console.log($$s.filter(it => it % 2 == 0).val()); // 2, 4
   *
   * @param {function} fn
   * @return {Slot} this
   * */filter:function(a){var b=this.val();return this.val(b.filter(a))},/**
   * slice the Slot's value
   *
   * @example
   * const $$s = $$([1, 2, 3, 4]);
   * console.log($$s.slice(1, 2).val()); // [2]
   *
   * @return {Slot} this
   * */slice:function(){var a=this.val();return this.val(a.slice.apply(a,Array.from(arguments)))},/**
   * shift the Slot's value
   *
   * @example
   * const $$s = $$([1, 2, 3, 4]);
   * console.log($$s.shift().val()); // 2, 3, 4
   *
   * @return {Slot} this
   * */shift:function(){return this.val().shift(),this.touch(),this},/**
   * shift the Slot's value
   *
   * @example
   * const $$s = $$([2, 3, 4]);
   * console.log($$s.unshift(1).val()); // 1, 2, 3, 4
   *
   * @return {Slot} this
   * */unshift:function(a){return this.val().unshift(a),this.touch(),this},/**
   * push the Slot's value
   *
   * @example
   * const $$s = $$([1, 2, 3]);
   * console.log($$s.push(4).val()); // 1, 2, 3, 4
   *
   * @return {Slot} this
   * */push:function(a){return this.val().push(a),this.touch(),this},/**
   * push the Slot's value
   *
   * @example
   * const $$s = $$([1, 2, 3]);
   * console.log($$s.pop().val()); // 1, 2
   *
   * @return {Slot} this
   * */pop:function(){return this.val().pop(),this.touch(),this},/**
   * reverse the Slot's value
   *
   * @example
   * const $$s = $$([1, 2, 3]);
   * console.log($$s.pop().val()); // [3, 2, 1]
   *
   * @return {Slot} this
   * */reverse:function(){return this.val(this.val().reverse()),this}});return{Slot:f,mutate:h,mutateWith:function(a){return h(a.map(function(a){var c=b(a,2),d=c[0],e=c[1];return[d,e&&e.apply(d,[d.val()])]}))},mixin:i}});

//# sourceMappingURL=rimple.min.js.map
